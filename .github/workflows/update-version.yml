name: Auto Update LobeHub Version

on:
  schedule:
    # æ¯å¤© UTC 00:00 (åŒ—äº¬æ—¶é—´ 08:00) è¿è¡Œ
    - cron: '0 0 * * *'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  check-and-update:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Check, Update and Notify
        id: update_script
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TELEGRAM_TOKEN: ${{ secrets.TELEGRAM_TOKEN }}
          TELEGRAM_TO: ${{ secrets.TELEGRAM_TO }}
        run: |
          python -c "
          import re
          import json
          import os
          import urllib.request
          import sys
          import html

          file_path = 'README.md'
          api_url = 'https://api.github.com/repos/lobehub/lobehub/releases/latest'

          def get_semver(ver_str):
              # æ”¯æŒ v2.0.2 vs v2.0.0-next.389 æ¯”è¾ƒ
              clean_ver = ver_str.lstrip('v').split('-')[0]  # å»æ‰ -next.389
              nums = [int(x) for x in clean_ver.split('.') if x.isdigit()]
              return nums + [0] * (3 - len(nums))  # è¡¥é½ [major, minor, patch]

          def send_telegram(token, chat_id, version, body):
              if not token or not chat_id:
                  print('::warning::Telegram secrets not set.')
                  return
              
              decoded_body = html.unescape(body)
              print(f'   Decoded preview: {decoded_body[:100]}...')
              
              # è¶…çº§ç®€å•æ¸…ç†ï¼šåªä¿ç•™çº¯æ–‡æœ¬ + å…³é”®é“¾æ¥
              plain_text = re.sub(r'<[^>]+>', '', decoded_body)  # ç§»é™¤æ‰€æœ‰ HTML
              
              # ä¿ç•™ issue/commit å¼•ç”¨æ ¼å¼
              plain_text = re.sub(r'\[#(\d+)\]\([^)]+\)', r'#\1', plain_text)
              plain_text = re.sub(r'\[([a-f0-9]{7,})\]\([^)]+\)', r'\1', plain_text)
              
              # æ¸…ç†ç©ºè¡Œ
              plain_text = re.sub(r'\n\s*\n\s*\n+', '\n\n', plain_text).strip()
              
              # Markdown æ ¼å¼ï¼ˆæœ€ç¨³å®šï¼‰
              title_link = f'[v{version}](https://github.com/lobehub/lobe-chat/releases/tag/{version})'
              text_content = f'ğŸš€ *LobeHub (Choreo) Update Detected!*\n\n*New Version:* {title_link}\n\n{plain_text}'
              
              if len(text_content) > 4096:
                  text_content = text_content[:4090] + '\n\n*(truncated)*'
              
              url = f'https://api.telegram.org/bot{token}/sendMessage'
              payload = {
                  'chat_id': chat_id,
                  'text': text_content,
                  'parse_mode': 'Markdown',
                  'disable_web_page_preview': False,
              }
              headers = {'Content-Type': 'application/json'}
              
              try:
                  req = urllib.request.Request(url, data=json.dumps(payload).encode(), headers=headers)
                  urllib.request.urlopen(req)
                  print('-> Telegram OK (Markdown)')
                  return
              except Exception as e:
                  print(f'::error::Markdown failed: {e}')
              
              # Fallback: çº¯æ–‡æœ¬
              payload['parse_mode'] = ''
              payload['text'] = f'LobeHub {version}\n\n{plain_text[:2000]}'
              try:
                  req = urllib.request.Request(url, data=json.dumps(payload).encode(), headers=headers)
                  urllib.request.urlopen(req)
                  print('-> Pure text OK')
              except Exception as e2:
                  print(f'::error::All failed: {e2}')

          try:
              if not os.path.exists(file_path):
                  print('::error::README.md not found')
                  sys.exit(1)

              with open(file_path, 'r', encoding='utf-8') as f:
                  content = f.read()

              # åŒ¹é… # Version ä¸‹çš„ç‰ˆæœ¬å·ï¼Œæ”¯æŒå¤šè¡Œæ ¼å¼
              ver_match = re.search(r'# Version\s*\n?\s*(v[^\s\n]+)', content, flags=re.MULTILINE)
              if not ver_match:
                  print('::warning::Cannot find current version in README format.')
                  sys.exit(0)
              local_ver = ver_match.group(1).strip()
              print(f'Local Version: {local_ver}')

              # è·å–æœ€æ–°æ­£å¼ç‰ˆ release
              req = urllib.request.Request(api_url)
              token = os.environ.get('GITHUB_TOKEN')
              if token:
                  req.add_header('Authorization', f'token {token}')

              with urllib.request.urlopen(req) as resp:
                  data = json.loads(resp.read().decode())

              remote_ver = data['tag_name']
              remote_body = data.get('body') or ''
              print(f'Remote Version: {remote_ver}')

              if get_semver(remote_ver) > get_semver(local_ver):
                  print('-> New release found! Updating...')

                  # æ›´æ–° Version è¡Œ
                  content = re.sub(
                      r'(# Version\s*\n?\s*)v[^\s\n]+',
                      r'\1' + remote_ver,
                      content,
                      count=1,
                      flags=re.MULTILINE,
                  )

                  # æ›´æ–° Releases éƒ¨åˆ†
                  content = re.sub(
                      r'(# Releases\s*)([\s\S]*)',
                      '# Releases\n\n' + remote_body,
                      content,
                      count=1,
                  )

                  with open(file_path, 'w', encoding='utf-8') as f:
                      f.write(content)

                  with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                      f.write('updated=true\nnew_version=' + remote_ver + '\n')

                  send_telegram(
                      os.environ.get('TELEGRAM_TOKEN'),
                      os.environ.get('TELEGRAM_TO'),
                      remote_ver,
                      remote_body,
                  )
              else:
                  print('-> Local version is up to date.')

          except Exception as e:
              print(f'::error::Script failed: {e}')
              sys.exit(1)
          "

      - name: Commit and Push changes
        if: steps.update_script.outputs.updated == 'true'
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git add README.md
          git commit -m "docs: update to ${{ steps.update_script.outputs.new_version }}"
          git push

  cleanup-runs:
    runs-on: ubuntu-latest
    needs: check-and-update
    if: always()
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          repository: ${{ github.repository }}
          retain_days: 7
          keep_minimum_runs: 6
