name: Auto Update Open-WebUI Version

on:
  schedule:
    # æ¯å¤© UTC 00:00 (åŒ—äº¬æ—¶é—´ 08:00) è¿è¡Œ
    - cron: '0 0 * * *'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  check-and-update:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Check, Update and Notify
        id: update_script
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TELEGRAM_TOKEN: ${{ secrets.TELEGRAM_TOKEN }}
          TELEGRAM_TO: ${{ secrets.TELEGRAM_TO }}
        run: |
          python -c "
          import re
          import json
          import os
          import urllib.request
          import sys
          import html

          # --- é…ç½® ---
          file_path = 'README.md'
          api_url = 'https://api.github.com/repos/lobehub/lobehub/releases/latest'

          def get_semver(ver_str):
              clean_ver = ver_str.lstrip('v')
              return [int(x) for x in clean_ver.split('.') if x.isdigit()]

          def clean_markdown_for_telegram(text):
              if not text:
                  return ''
              
              # 1. ç§»é™¤ HTML æ³¨é‡Š text = re.sub(r'', '', text, flags=re.DOTALL)
              
              # 2. ç§»é™¤åº•éƒ¨çš„ Back to top å›¾ç‰‡/é“¾æ¥å— (åŒ¹é… <div align=right>...</div>)
              text = re.sub(r'<div[^>]*>.*?</div>', '', text, flags=re.DOTALL)
              
              # 3. ç§»é™¤æŠ˜å æ ‡ç­¾ï¼Œä¿ç•™å†…å®¹ (<details>, <summary>)
              text = re.sub(r'</?(details|summary|kbd)>', '', text)
              
              # 4. ç§»é™¤ Markdown å›¾ç‰‡ (![...](...)) å’Œ HTML å›¾ç‰‡
              text = re.sub(r'!\[.*?\]\(.*?\)', '', text)
              text = re.sub(r'<img[^>]*>', '', text)
              
              # 5. å°† <br> æ›¿æ¢ä¸ºæ¢è¡Œ
              text = re.sub(r'<br\s*/?>', '\n', text)
              
              # 6. å¤„ç† Markdown é“¾æ¥ [text](url) -> ä»…æå– text æˆ–è€…ä¿ç•™æ ¼å¼
              # ä¸ºäº† Telegram å®‰å…¨ï¼Œæˆ‘ä»¬å…ˆè½¬ä¹‰ï¼Œå†æ‰‹åŠ¨æ¢å¤é“¾æ¥å’ŒåŠ ç²—
              return text

          def send_telegram(token, chat_id, version, raw_body):
              if not token or not chat_id:
                  print('::warning::Telegram secrets not set.')
                  return

              # --- é¢„å¤„ç†æ¶ˆæ¯ä½“ ---
              # å…ˆæ¸…æ´—æ‰ä¸éœ€è¦çš„ HTML ç»“æ„å’Œå›¾ç‰‡
              cleaned_text = clean_markdown_for_telegram(raw_body)
              
              # HTML è½¬ä¹‰ (é˜²æ­¢å†…å®¹ä¸­çš„ < > & ç ´å Telegram æ ¼å¼)
              safe_text = html.escape(cleaned_text)

              # --- æ ¼å¼åŒ–å¢å¼º (åœ¨è½¬ä¹‰åè¿›è¡Œ) ---
              
              # 1. æ ‡é¢˜åŠ ç²—: å°† ### Title è½¬æ¢ä¸º <b>Title</b>
              # (?m) å¼€å¯å¤šè¡Œæ¨¡å¼
              safe_text = re.sub(r'(?m)^#{1,6}\s+(.*)$', r'<b>\1</b>', safe_text)
              
              # 2. è¿˜åŸå¹¶æ ¼å¼åŒ–é“¾æ¥: [Text](Url) -> <a href='Url'>Text</a>
              # æ³¨æ„ï¼šUrl ä¹‹å‰è¢« html.escape è½¬ä¹‰è¿‡ (ä¾‹å¦‚ & å˜æˆäº† &amp;)ï¼Œè¿™å¯¹ href æ˜¯åˆæ³•çš„
              link_pattern = r'\[([^\]]+)\]\((https?://[^)]+)\)'
              safe_text = re.sub(link_pattern, r'<a href="\2">\1</a>', safe_text)
              
              # 3. å¤„ç† sup æ ‡ç­¾ (é€šå¸¸ç”¨äºå‘å¸ƒæ—¥æœŸ)
              safe_text = re.sub(r'&lt;sup&gt;(.*?)&lt;/sup&gt;', r'<i>\1</i>', safe_text)

              # 4. ç§»é™¤å¤šä½™çš„è¿ç»­æ¢è¡Œ
              safe_text = re.sub(r'\n{3,}', '\n\n', safe_text)

              # æ„å»ºæœ€ç»ˆæ¶ˆæ¯
              text_content = f'ğŸš€ <b>LobeHub (Choreo) Update Detected!</b>\n\n<b>New Version:</b> {version}\n\n{safe_text}'
              
              # æˆªæ–­ä¿æŠ¤
              if len(text_content) > 4000:
                  text_content = text_content[:4000] + '\n...(content truncated)...'

              url = f'https://api.telegram.org/bot{token}/sendMessage'
              
              payload = {
                  'chat_id': chat_id,
                  'text': text_content,
                  'parse_mode': 'HTML',
                  'disable_web_page_preview': True
              }
              
              headers = {'Content-Type': 'application/json'}
              
              try:
                  req = urllib.request.Request(url, data=json.dumps(payload).encode(), headers=headers)
                  urllib.request.urlopen(req)
                  print(f'-> Telegram notification sent to {chat_id}')
              except Exception as e:
                  print(f'::error::HTML Send Failed: {e}')
                  # é™çº§é‡è¯• (çº¯æ–‡æœ¬)
                  del payload['parse_mode']
                  payload['text'] = f'Update: {version}\n\n{cleaned_text}'[:4000]
                  try:
                      urllib.request.urlopen(urllib.request.Request(url, data=json.dumps(payload).encode(), headers=headers))
                      print('-> Sent as plain text fallback.')
                  except Exception as e2:
                      print(f'::error::Fallback failed: {e2}')

          try:
              # 1. æ£€æŸ¥æ–‡ä»¶
              if not os.path.exists(file_path):
                  print('::error::README.md not found!')
                  sys.exit(1)

              with open(file_path, 'r', encoding='utf-8') as f:
                  content = f.read()

              # 2. è·å–æœ¬åœ°ç‰ˆæœ¬
              ver_match = re.search(r'# Version\s+(v[\d\.]+)', content)
              if not ver_match:
                  print('::warning::Cannot find current version in README format.')
                  sys.exit(0)
              local_ver = ver_match.group(1)
              print(f'   Local Version: {local_ver}')

              # 3. è·å–è¿œç¨‹ç‰ˆæœ¬
              req = urllib.request.Request(api_url)
              if os.environ.get('GITHUB_TOKEN'):
                  req.add_header('Authorization', f'token {os.environ.get("GITHUB_TOKEN")}')
              
              with urllib.request.urlopen(req) as response:
                  data = json.loads(response.read().decode())
                  remote_ver = data['tag_name']
                  remote_body = data['body']
              print(f'   Remote Version: {remote_ver}')

              # 4. å¯¹æ¯”ä¸æ‰§è¡Œ
              if get_semver(remote_ver) > get_semver(local_ver):
                  print(f'-> New version found! Updating...')

                  # [ä¿®å¤1] æ›´æ–° README - Version
                  # ä½¿ç”¨ r'\g<1>' + remote_ver é¿å… f-string ä¸­çš„åæ–œæ è½¬ä¹‰é—®é¢˜
                  content = re.sub(r'(# Version\s+)(v[\d\.]+)', r'\g<1>' + remote_ver, content, count=1)
                  
                  # æ›´æ–° README - Releases (ä¿æŒåŸå§‹å†…å®¹ï¼Œä¸æ¸…æ´—ï¼Œå› ä¸º README æ”¯æŒ HTML)
                  content = re.sub(r'(# Releases\s*)([\s\S]*)', f'# Releases\n\n{remote_body}', content, count=1)

                  with open(file_path, 'w', encoding='utf-8') as f:
                      f.write(content)
                  
                  # è¾“å‡º Output
                  with open(os.environ['GITHUB_OUTPUT'], 'a') as gh_out:
                      gh_out.write('updated=true\n')
                      gh_out.write(f'new_version={remote_ver}\n')
                  
                  # å‘é€é€šçŸ¥ (ä½¿ç”¨æ¸…æ´—åçš„é€»è¾‘)
                  send_telegram(
                      os.environ.get('TELEGRAM_TOKEN'), 
                      os.environ.get('TELEGRAM_TO'), 
                      remote_ver, 
                      remote_body
                  )
                  
              else:
                  print('-> Local version is up to date.')

          except Exception as e:
              print(f'::error::Script failed: {e}')
              sys.exit(1)
          "

      - name: Commit and Push changes
        if: steps.update_script.outputs.updated == 'true'
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git add README.md
          git commit -m "docs: update to ${{ steps.update_script.outputs.new_version }}"
          git push

  cleanup-runs:
    runs-on: ubuntu-latest
    needs: check-and-update
    if: always()
    steps:
      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          repository: ${{ github.repository }}
          retain_days: 7
          keep_minimum_runs: 6
